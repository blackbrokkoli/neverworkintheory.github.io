so in this talk i'm going to tell you the story behind sql lancer which is a tool that we designed and developed to automatically test database management systems now i assume that many of you are not directly working on developing database management systems which is why i will focus on general insights that you might be able to apply on testing your project so just to ensure that we're all on the same page and in our work we wanted to test database functional systems that expect queries or statements written in the structured query language or short c color sql as perhaps most of you knows we can for example use this language to create tables to insert data into them and then again fetch data using a select statement now in the previous talks we already heard a bit about testing so how can we write test cases that could test such systems

well one approach would be to just write them in sql we could for example specify the test case such as here taken from the mysql test to it and then in a separate file specify the expected output and while there are some frameworks that make this process a bit easier i would argue that it's still always challenging and time consuming to write manual test cases especially considering for such complex systems where we need a huge test suites so in our work we ask ourselves can we automate the test process and this brings us to two challenges first of all if we want to have an automated testing approach we need a test case and in our case this means that we need to generate a database and a query that we can then validate so looking into what's already out there we can find tools such as for example sql smith sql smith is an effective and widely used brand new curry generation tool that mutates and generates complex sql statements that might cause for example a crash in the database system that developers can then fix so i would say that this is already a solved challenge so we can use either this random generation approach or another one to generate the test cases now what was still an open challenge is the so-called test oracle problem namely we want to validate the queries result so what's a test oracle a test oracle is basically the mechanism that determines whether a test has passed or failed and for regression testing for writing manual test cases we typically as the developer our developers are or provide the test oracle but this is often difficult even for manually written test cases and i want to illustrate this based on a concrete example you can see a test case that actually allowed us to find and report a bug in my sql you can see here that we have two tables c0 and t1 each of which holds a floating point value namely a positive zero and a negative zero and then we instruct mysql to fetch the cross product of all records from these two tables where the column errors to the same value now what's the expected output here

i would argue that it's disputable whether the predicate here should evaluate to true or false because we could for example look at the binary representation of these two floating point numbers to realize that the sign bit differs and based on this it would make sense that the equality operator relates to false and my sequel for this case would return an empty result but most programming languages such as java c and so on they actually define the semantics that this equality operator should able to do for for these values and in this case mysql would fetch error so at this point in a talk you have to trust me actually mysql is expected to fetch the record but when we tested the latest version of it it still failed to do so we reported this as a bug to the developers who then fixed it for the next release of my sequel but the point here is actually that we could find this bug without having an was on whether bradycat should already do true or not and whether any results or any records should be fetched we basically had this test oracle that told us that the result returned correct now we actually developed a couple of test oracles the one i'm going to present today is turning logic partitioning or short tlb and if i had to explain the approach in half a sentence i would basically say the idea is to test the database management system against itself the idea is quite generous i want to explain it based on an analogy so if i ever meet in person it will it's very likely that this will be in the coffee kitchen because i like to drink lots of coffee and let's also assume that there is a bowl with fruits containing both tangerines and also clementines now i'm actually very bad at telling these different citrus foods apart they all look the same to me so this is what i tell you in order to start some small talk and you might actually respond that you can clearly tell the difference so challenge you to show me but how can i test your understanding of tantrums versus clementines without even having this understanding myself well the strategy that i would apply would be the following first i would ask you to please bring me all the clementines and you would go ahead and fetch perhaps two of the fruits i would then put them back into the bowl shuffle them around and then ask you to bring me all foods that are not clementines you would bring the apple which i could recognize along with the other orange looking fruits and i believe that already some of you see where this is going because you brought me two fruits first and then you brought me four fruits over all six fruits but there are only five fruits in the bowl meaning that you likely classified a fruit as being both a tangerine and a clementine so the high level insight here is that every object in the universe and also in the bowl is either clementine or not a climate and we use this insight to basically partition all the objects in the bowl of course you could always say uh you could always consistently classify tensions as clementines and the other way around meaning that we cannot detect all the bugs but neither can test uh test cases so this is a limitation that we have to live with how do we now apply this to sql now we have any kind of given predicate p and a row r rather than a fruit exactly one of the following must hold the predicts to true not the predicate or is the true meaning that it allows to false and then since in sql we also have to deal with null values we have to deal with the case where p might evolve to another and based on this we can now take any kind of data in our table any kind of intermediate result and partition it into three parts then we do those for the predicate where it's true whenever it's too false and varied errors do not how did this now allow us to detect the bug from the motivating example well we first generated this query that basically corresponds to counting the number of fruits in the bowl so we simply fetch the cross product of all values from these two tables and there my sql returned a single record then we generated this more complex three queries based on this random predicate p you can see here that we have the non-negated version the negative version and this null version overall we expect that this should compute the same result however mysql returned an empty result set here which allowed us to find and report back the technique is actually quite versatile in the sense that we can test multiple different kind of sql features here only focused on work losses so we basically had this random generation approach to tackle this test case generation problem and now we propose terminological partitioning to tackle this test test oracle problem can such a simple technique be effective is the next natural question well i used sql answer tlb being one of these approaches that we proposed to find all 450 unique and previously unknown bugs in baidu's database venture systems that you have all heard of or know

and what should you take away from this talk well while the specific technique data primarily works for data-oriented systems it is based actually on a more generic more general kind of technique namely if we look at this from an abstract level we basically can realize that we had a test case that we executed to obtain a result and based on this we derived a new test case for which we could then provide a test oracle and this does metamorphic testing now what you can do is you could try of course to come up with a metamorphic testing technique for you but an alternative would also be to check if there are any already existing approaches for example by looking on google scholar

yeah and with that summarize and the takeaways so manually writing test cases is time intensive and requires detailed domain knowledge and you might actually face a similar problem in your work so what we propose is to couple random test case generation with metamorphic testing which turned out to effectively complement manually written test cases with listening
