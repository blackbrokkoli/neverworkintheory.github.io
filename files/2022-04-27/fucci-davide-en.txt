uh my name is david hello from southern sweden and uh i would like to start telling a little bit about my personal story with with test driven development this started when i was a graduate student and as any graduate student i had some side projects i was working on mainly using ruby on rails and if you're familiar with the framework and the community banded framework this is kind of the community that swears and it's devout to unit testing and specifically to testimony development also the same time i was deciding about the topic for my dissertation and i found it interesting to study something that the practitioner community came up with something that they invented and then adopted rather than coming up with something academic and that maybe you no one will ever end up using in practice and let's start with one of the hidden costs perhaps maybe false advertisement of what testimony development is this is usually how tdd is presented to you it's a simple iterative three-step process we have a red and green face that kind of map on the colors of the test frameworks uh usually used to indicate failing or passing the street we start by writing a failing test case so we are in the so-called red phase and then we move on to the green phase by writing enough code to make the test pass then we have an additional blue face where we can refactor and the cycle continues by adding new new failing test cases and so on in reality i believe that that's an oversimplification and actually honestly a misconception of what tdd is in fact it looks a bit more like this there's two distinct phases with different uh future one driven by unit test cases as contracts that you need to fulfill where a lot of things can go wrong you need to backtrack you need to make changes to test cases you need to fight against your desire to write more testosterone than actually necessary just because you know you're going to write it eventually anyways and then there's a second part where you try to align the need of your code or the need that your code may have with the design and usually we call this refactor and this brings its own set of complications so for example depending on the refactoring you may need to align your old test cases with the new code design you might need to fix some regression bugs that you you cause during refactoring another important decision is actually for the developer to decide when they are satisfied with the quality of the code so that they can move on to the next next tdd cycle and so here my first uh hidden cost is that tdd may not be as simple as it seemed and when looking at the re looking at the real complexity of uh tdd i kind of felt like okay why would anybody do that and i turn out it turned out i wasn't alone there are other researchers that have looked into how steep is the tdd learning curve how much of an overhead is perceived to be how it leads developer to actually focus on fp tests rather than testing said paths and all this claim collided with the benefits or the claim benefits of ddd so the fact that test driven development improves design leads to lower defects improves developers productivity as developers now can rely on this extensive safety net made of unit test so for us this kind of backed the question are developers who claim to do tdd actually doing it so we perform a study with professional developers that were trained on gdd and asked them to a new feature to a legacy system now this system is a real-world system not the kata kind of exercise that people usually employ to practice test-driven development and as a full-fledged architecture dependency on external apis complicated xml passing and so on plus we instrumented the developers ides with a plug-in which collects activities happening in the ide itself and which we could eventually map into the tdd activities and into tdd phases and we started looking the results and this is what we get here i'm showing just an example of how different the different activities are supposed to be in a tdd fashion each activity has a type and a duration so for example here you can see that this person started with implementing tests first shown in yellow then he moved on to adding test cases without the counterpart production code in orange and then there was a loss and this person switched for roughly half an hour to a test last kind of approach uh shooting red and then he added more cycles he continued developing using test first and doing refactoring which are showing in light blue only at the end and so we put all these measurements together hours of development from more than 60 professional developers and run this data through some statistical model and what did we learn well we observed that the major benefit of doing test driven development is so the only things or the things that counts that explains the perceived benefits or the claim benefits of tdd like weather code quality as well as productivity well that thing is not the rigid religious adherence to test driven development cycle but rather how fine-grained are the activities in the process so the fact that each activity such as writing code and writing tests or the other way around even writing testing code and then refactoring are kept within a short and consistent time interval so that's the secret sauce of tdd and notice that this granularity is a by-product of test driven development it's not enforced by it it's recommended to keep the cycle short within five to ten minutes although we observe that very few people do that especially in the case of legacy code and importantly this rhythm of tdd is directly impacted by the scope of the test cases defined to initiate each cycle so one suggestion here is to be really conscious on the scope of the test case it's really working in baby steps that's what helps so we have now we now know that you can benefit from tdd although not directly because of this test first approach but rather because it makes more compelling to write small unit tests finally another aspect we have started and that i actually found quite interesting was to understand how developers actually are enjoying the tdd as a process here on the one hand we have existing knowledge existing literature in software engineering that tells us that epi developers are better at problem solving and on the other hand we have this a typical different way of developing software where unit tests kind of control and guide developers decisions so we conducted a small experiment this time with students novices and tdd developers comparing comparing them to non-tdd developers and we asked them to perform a series of development tasks but also ask them to report their perceived emotional state using this pictorial mannequin here called sam basically they could mark on the mannequin what corresponds to their states such as happiness excitement frustration boredom etc and here we observe another hidden cost of test driven development we observe that tddrs are not as happy as other developers and when investigating this we find out that the reason is that tdd forces programmers into this mind-numbing cycle that actually clips their creative wings and especially in the case of novices they are just uncomfortable with the tdd counter intuitive test them right production code kind of thinking so this is uh my third takeaway here so yes although tdd is not as simple as it might seem it works if you follow baby step but nonetheless it comes with an emotional cost which which you should be aware of and that's really all i have for you today thank you you can of course approach me and ask me more and connect with me this is my email and my twitter handler thank you for your time
