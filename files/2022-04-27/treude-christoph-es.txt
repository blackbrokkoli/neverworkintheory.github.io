Me gustaría empezar hablando de tres líneas de código Python que espero que puedan ver en mi pantalla ahora. Un código bastante sencillo: Tengo tres líneas, tengo una lista de enteros, y me gustaría eliminar los duplicados de esta lista de enteros en Python. Podemos hacer esto con el método fromkeys del diccionario y luego podemos devolver el resultado a una lista. Y luego queremos imprimir nuestra nueva lista desduplicada.
Ahora bien, si has hecho un poco de programación en Python puede que sepas que este código no funciona realmente. Me da un mensaje de error del compilador. Y esto es lo que muestra el mensaje de error del compilador: me dice que el objeto list no es invocable. Ahora bien, no estoy tratando de llamar a un objeto list -tengo una lista de enteros y quiero eliminar los duplicados de la misma- por lo que este mensaje de error yo diría que no es súper útil. No estoy tratando de llamar a una lista, quiero desduplicar una lista, así que ¿qué es lo que está mal?
Lo que ocurre es que el mensaje de error se refiere a lo que el compilador estaba tratando de hacer en lugar de lo que yo estaba tratando de hacer. Y antes de decirte cuál es el problema del código, déjame decirte lo antiguo que es este problema. Y para ello tenemos que remontarnos a la época en que los trabajos de informática se escribían a máquina. Estamos en 1976, y estamos viendo aquí un artículo con un título maravilloso, "Cómo diseñar lenguajes para hacer la programación lo más difícil posible", escrito por Richard Wexelblat, que por cierto fue la primera persona en el mundo en obtener un doctorado en un departamento de ciencias de la computación. Esto fue en los años 60 y luego, en 1976, escribió este artículo, "Cómo diseñar lenguajes para hacer la programación lo más difícil posible". Uno de los párrafos más interesantes de este documento es: "Para maximizar la dificultad para el usuario es importante que los mensajes de error reflejen lo que hizo el programa y no lo que hizo el usuario." Y volviendo a mirar el mensaje de error de nuestro compilador, yo diría que no hemos avanzado mucho desde esta afirmación: el mensaje de error sigue siendo todo sobre lo que el compilador estaba tratando de hacer.
Ahora bien, en 1976, si te encontrabas con un mensaje de error del compilador, no había muchos lugares a los que pudieras acudir en busca de ayuda. Tal vez había un libro de texto, "A Discipline of Programming" por edsger Dijkstra publicado en el mismo año, también 1976, posiblemente mucho antes de que apareciera Python. Pero eso ha cambiado bastante. Hoy en día, si nos encontramos con un mensaje de error del compilador, podemos hacer muchas cosas gracias a Internet. Podemos quejarnos en Twitter, por supuesto, eso es muy importante, pero también podemos ir a la documentación oficial de Python que tenemos accesible muy fácilmente. Podemos buscar código similar en GitHub que quizás también intente eliminar los duplicados de la lista, y por supuesto tenemos el foro de respuestas a preguntas favorito de todo el mundo, Stack Overflow.
Y en este caso concreto, efectivamente, hay un hilo de Stack Overflow que nos dice perfectamente cuál es el problema de nuestro código: No utilices tuple, list u otros nombres especiales como nombre de variable, eso es probablemente lo que está causando tu problema. Respuesta aceptada, 939 votaciones positivas, se ve muy bien, y efectivamente ese es exactamente el problema del código. Si cambié el nombre de la variable list por otro que no fuera list u otra palabra clave reservada, el código funciona perfectamente.
Así que, al llegar a esta situación como investigadores, nos preguntamos bien si el - si el mensaje de error bueno está tan lejos, y tenemos que buscar en Google, y tenemos que leer un montón de hilos de Stack Overflow para encontrarlo, ¿qué podemos hacer para hacer esto más fácil? ¿Podemos mejorar el mensaje de error - yo diría - directamente en el IDE? Y de eso es de lo que me gustaría hablar hoy.
Lo hacemos en una serie de pasos. Lo primero que hacemos es analizar el mensaje de error. En este ejemplo, "error de tipo el objeto list no es llamable". Luego usamos este mensaje de error para construir la consulta que enviamos automáticamente a Stack Overflow. Y resulta, experimentamos con esto un poco, resulta que dependiendo del error a veces tiene sentido enviar el mensaje de error detallado, a veces tiene sentido enviar un poco de código, y a veces tiene sentido sólo enviar el tipo.
En cualquier caso, construimos una consulta que enviamos a Stack Overflow. Seleccionamos una respuesta basándonos en características como, si la respuesta ha sido aceptada, si hay código en ella, cómo ha sido recibida a través de votaciones positivas y negativas. Luego personalizamos un poco la respuesta, porque muchas respuestas se refieren a nombres de variables específicas que pueden ser muy diferentes a los nombres de variables que vemos en nuestro IDE, así que reemplazamos, en la medida de lo posible, los nombres de variables que vemos en la respuesta con nombres de variables que realmente han sido utilizados por el usuario. Y finalmente resumimos todo, porque como sabes, algunas de las respuestas en Stack Overflow son bastante largas.
Y como resultado, en este caso sí que podemos producir un mensaje de error mucho mejor, yo diría que en lugar de decir que la lista no es invocable ahora podemos decir, no uses list u otros nombres especiales como nombre de variable.
Implementamos todo esto en una herramienta llamada Pycee, que es la abreviatura de Python compiler error enhancer, y esa es exactamente la salida de Pycee.
Así que, como somos investigadores, también queríamos evaluar si esto funciona. Funciona en el ejemplo que acabo de ver, pero ¿funciona en un entorno más general? Para ello, reclutamos a un total de 16 desarrolladores de software profesionales y le dimos a cada uno de ellos dos tareas. Tomamos estas tareas de uno de esos sitios web de ejercicios de programación en Python, en este caso PracticePython.org creo, que tiene un montón de pequeños ejercicios como Fibonacci y así sucesivamente. Y entonces, la mitad de los participantes - no, para la mitad de las tareas, por lo que cada participante hizo dos tareas. Para una de las tareas se utilizó nuestra versión de Stack Overflow Pycee, y para la otra se utilizó la línea de base, porque queríamos tener algo para comparar. Y en este caso elegimos como línea de base la documentación oficial de, de Python sobre estos mensajes de error.
En total, nuestros participantes, o cada uno de los 16 participantes, trabajaron en dos tareas. Encontraron un total de 115 errores de compilación como parte del trabajo en estas tareas, lo que como saben es bastante normal, normalmente cuando programamos algo, nos encontraremos con errores de compilación incluso si somos bastante buenos en ello. Se encontraron con 115 errores del compilador, alrededor de la mitad con nuestra versión mejorada de los errores del compilador y alrededor de la mitad con la línea de base con la que estamos tratando de comparar. Así que en este caso, afortunadamente, los resultados de Pycee en el lado derecho, afortunadamente, en términos de la utilidad percibida en general, estuvieron de acuerdo en que nuestros mensajes de error eran más útiles que la línea de base y también estuvieron de acuerdo en que nuestros mensajes de error les ayudaron a ahorrar tiempo en comparación con la línea de base la diferencia en este caso no es tan grande.
Entonces, ¿qué me gustaría que sacaran de esto? Dos cosas. La primera, que los mensajes de error sean de uso colectivo. Creo que nuestro estudio fue un buen ejemplo que muestra que el poder de la multitud, en este caso en Stack Overflow, puede producir mejores mensajes de error y mejores explicaciones de los mensajes de error que la información que tenemos disponible en la documentación oficial que fue escrita por un número mucho menor de personas, por supuesto. Si los mensajes de error son de origen colectivo, por supuesto, no son todos correctos, pero entonces podemos desarrollar herramientas automatizadas que ayuden a filtrar estos datos y producir los mensajes de error correctos en el momento adecuado.
Eso es todo para mí - muchas gracias por escuchar.

