---
layout: page
title: To Do
---
<p><a href="../tex/todo.bib">BibTeX</a> | <a href="../tex/todo.pdf">PDF</a></p>

<p><a href="#A">A</a> <a href="#B">B</a> <a href="#C">C</a> <a href="#D">D</a> <a href="#E">E</a> <a href="#F">F</a> <a href="#G">G</a> <a href="#H">H</a> <a href="#I">I</a> <a href="#J">J</a> <a href="#K">K</a> <a href="#L">L</a> <a href="#M">M</a> <a href="#N">N</a> <a href="#O">O</a> <a href="#P">P</a> <a href="#Q">Q</a> <a href="#R">R</a> <a href="#S">S</a> <a href="#T">T</a> <a href="#U">U</a> <a href="#V">V</a> <a href="#W">W</a> <a href="#X">X</a> <a href="#Y">Y</a> <a href="#Z">Z</a></p>

<h2 id="A">A</h2>
<h2 id="B">B</h2>

<p id="Bao2021" class="bib"><cite>Bao2021</cite>
Lingfeng Bao, Xin Xia, David Lo, and Gail C. Murphy:
"<a href="https://doi.org/10.1109/tse.2019.2918536">A Large Scale Study of Long-Time Contributor Prediction for GitHub Projects</a>".
<em>IEEE Transactions on Software Engineering</em>, 47(6), 2021,
<a class="doi" href="https://doi.org/10.1109/tse.2019.2918536">10.1109/tse.2019.2918536</a>.
</p>
<blockquote class="abstract">The continuous contributions made by long time contributors (LTCs) are a key factor enabling open source software (OSS) projects to be successful and survival. We study Github as it has a large number of OSS projects and millions of contributors, which enables the study of the transition from newcomers to LTCs. In this paper, we investigate whether we can effectively predict newcomers in OSS projects to be LTCs based on their activity data that is collected from Github. We collect Github data from GHTorrent, a mirror of Github data. We select the most popular 917 projects, which contain 75,046 contributors. We determine a developer as a LTC of a project if the time interval between his/her first and last commit in the project is larger than a certain time $T$. In our experiment, we use three different settings on the time interval: 1, 2, and 3 years. There are 9,238, 3,968, and 1,577 contributors who become LTCs of a project in three settings of time interval, respectively. To build a prediction model, we extract many features from the activities of developers on Github, which group into five dimensions: developer profile, repository profile, developer monthly activity, repository monthly activity, and collaboration network. We apply several classifiers including naive Bayes, SVM, decision tree, kNN and random forest. We find that random forest classifier achieves the best performance with AUCs of more than 0.75 in all three settings of time interval for LTCs. We also investigate the most important features that differentiate newcomers who become LTCs from newcomers who stay in the projects for a short time. We find that the number of followers is the most important feature in all three settings of the time interval studied. We also find that the programming language and the average number of commits contributed by other developers when a newcomer joins a project also belong to the top 10 most important features in all three settings of time interval for LTCs. Finally, we provide several implications for action based on our analysis results to help OSS projects retain newcomers.</blockquote>

<p id="Barke2019" class="bib"><cite>Barke2019</cite>
Helena Barke and Lutz Prechelt:
"<a href="https://doi.org/10.7717/peerj-cs.241">Role clarity deficiencies can wreck agile teams</a>".
<em>PeerJ Computer Science</em>, 5, 2019,
<a class="doi" href="https://doi.org/10.7717/peerj-cs.241">10.7717/peerj-cs.241</a>.
</p>
<blockquote class="abstract">Background One of the twelve agile principles is to build projects around motivated individuals and trust them to get the job done. Such agile teams must self-organize, but this involves conflict, making self-organization difficult. One area of difficulty is agreeing on everybody's role. Background What dynamics arise in a self-organizing team from the negotiation of everybody's role? Method We conceptualize observations from five agile teams (work observations, interviews) by Charmazian Grounded Theory Methodology. Results We define role as something transient and implicit, not fixed and named. The roles are characterized by the responsibilities and expectations of each team member. Every team member must understand and accept their own roles (Local role clarity) and everbody else's roles (Team-wide role clarity). Role clarity allows a team to work smoothly and effectively and to develop its members' skills fast. Lack of role clarity creates friction that not only hampers the day-to-day work, but also appears to lead to high employee turnover. Agile coaches are critical to create and maintain role clarity. Conclusions Agile teams should pay close attention to the levels of Local role clarity of each member and Team-wide role clarity overall, because role clarity deficits are highly detrimental.</blockquote>

<p id="Bi2021" class="bib"><cite>Bi2021</cite>
Tingting Bi, Wei Ding, Peng Liang, and Antony Tang:
"<a href="https://doi.org/10.1016/j.jss.2021.111035">Architecture information communication in two OSS projects: The why, who, when, and what</a>".
<em>Journal of Systems and Software</em>, 181, 2021,
<a class="doi" href="https://doi.org/10.1016/j.jss.2021.111035">10.1016/j.jss.2021.111035</a>.
</p>
<blockquote class="abstract">Architecture information is vital for Open Source Software (OSS) development, and mailing list is one of the widely used channels for developers to share and communicate architecture information. This work investigates the nature of architecture information communication (i.e., why, who, when, and what) by OSS developers via developer mailing lists. We employed a multiple case study approach to extract and analyze the architecture information communication from the developer mailing lists of two OSS projects, ArgoUML and Hibernate, during their development life-cycle of over 18 years. Our main findings are: (a) architecture negotiation and interpretation are the two main reasons (i.e., why) of architecture communication; (b) the amount of architecture information communicated in developer mailing lists decreases after the first stable release (i.e., when); (c) architecture communications centered around a few core developers (i.e., who); (d) and the most frequently communicated architecture elements (i.e., what) are Architecture Rationale and Architecture Model. There are a few similarities of architecture communication between the two OSS projects. Such similarities point to how OSS developers naturally gravitate towards the four aspects of architecture communication in OSS development.</blockquote>

<p id="Blackwell2019" class="bib"><cite>Blackwell2019</cite>
Alan F. Blackwell, Marian Petre, and Luke Church:
"<a href="https://doi.org/10.1016/j.ijhcs.2019.06.009">Fifty years of the psychology of programming</a>".
<em>International Journal of Human-Computer Studies</em>, 131, 2019,
<a class="doi" href="https://doi.org/10.1016/j.ijhcs.2019.06.009">10.1016/j.ijhcs.2019.06.009</a>.
</p>
<blockquote class="abstract">Abstract This paper reflects on the evolution (past, present and future) of the 'psychology of programming' over the 50 year period of this anniversary issue. The International Journal of Human-Computer Studies (IJHCS) has been a key venue for much seminal work in this field, including its first foundations, and we review the changing research concerns seen in publications over these five decades. We relate this thematic evolution to research taking place over the same period within more specialist communities, especially the Psychology of Programming Interest Group (PPIG), the Empirical Studies of Programming series (ESP), and the ongoing community in Visual Languages and Human-Centric Computing (VL/HCC). Many other communities have interacted with psychology of programming, both influenced by research published within the specialist groups, and in turn influencing research priorities. We end with an overview of the core theories that have been developed over this period, as an introductory resource for new researchers, and also with the authors' own analysis of key priorities for future research.</blockquote>

<p id="Bogart2021" class="bib"><cite>Bogart2021</cite>
Chris Bogart, Christian KÃ¤stner, James Herbsleb, and Ferdian Thung:
"<a href="https://doi.org/10.1145/3447245">When and How to Make Breaking Changes</a>".
<em>ACM Transactions on Software Engineering and Methodology</em>, 30(4), 2021,
<a class="doi" href="https://doi.org/10.1145/3447245">10.1145/3447245</a>.
</p>
<blockquote class="abstract">Open source software projects often rely on package management systems that help projects discover, incorporate, and maintain dependencies on other packages, maintained by other people. Such systems save a great deal of effort over ad hoc ways of advertising, packaging, and transmitting useful libraries, but coordination among project teams is still needed when one package makes a breaking change affecting other packages. Ecosystems differ in their approaches to breaking changes, and there is no general theory to explain the relationships between features, behavioral norms, ecosystem outcomes, and motivating values. We address this through two empirical studies. In an interview case study, we contrast Eclipse, NPM, and CRAN, demonstrating that these different norms for coordination of breaking changes shift the costs of using and maintaining the software among stakeholders, appropriate to each ecosystem's mission. In a second study, we combine a survey, repository mining, and document analysis to broaden and systematize these observations across 18 ecosystems. We find that all ecosystems share values such as stability and compatibility, but differ in other values. Ecosystems' practices often support their espoused values, but in surprisingly diverse ways. The data provides counterevidence against easy generalizations about why ecosystem communities do what they do.</blockquote>

<p id="Butler2019" class="bib"><cite>Butler2019</cite>
Simon Butler and 8 others:
"<a href="https://doi.org/10.1109/tse.2019.2919305">On Company Contributions to Community Open Source Software Projects</a>".
<em>IEEE Transactions on Software Engineering</em>, 2019,
<a class="doi" href="https://doi.org/10.1109/tse.2019.2919305">10.1109/tse.2019.2919305</a>.
</p>
<blockquote class="abstract">The majority of contributions to community open source software (OSS) projects are made by practitioners acting on behalf of companies and other organisations. Previous research has addressed the motivations of both individuals and companies to engage with OSS projects. However, limited research has been undertaken that examines and explains the practical mechanisms or work practices used by companies and their developers to pursue their commercial and technical objectives when engaging with OSS projects. This research investigates the variety of work practices used in public communication channels by company contributors to engage with and contribute to eight community OSS projects. Through interviews with contributors to the eight projects we draw on their experiences and insights to explore the motivations to use particular methods of contribution. We find that companies utilise work practices for contributing to community projects which are congruent with the circumstances and their capabilities that support their short- and long-term needs. We also find that companies contribute to community OSS projects in ways that may not always be apparent from public sources, such as employing core project developers, making donations, and joining project steering committees in order to advance strategic interests. The factors influencing contributor work practices can be complex and are often dynamic arising from considerations such as company and project structure, as well as technical concerns and commercial strategies. The business context in which software created by the OSS project is deployed is also found to influence contributor work practices.</blockquote>

<h2 id="C">C</h2>
<h2 id="D">D</h2>

<p id="Danilova2021" class="bib"><cite>Danilova2021</cite>
Anastasia Danilova, Alena Naiakshina, Stefan Horstmann, and Matthew Smith:
"<a href="https://doi.org/10.1109/icse43902.2021.00057">Do you Really Code? Designing and Evaluating Screening Questions for Online Surveys with Programmers</a>".
<em>Proc. International Conference on Software Engineering (ICSE)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/icse43902.2021.00057">10.1109/icse43902.2021.00057</a>.
</p>
<blockquote class="abstract">Recruiting professional programmers in sufficient numbers for research studies can be challenging because they often cannot spare the time, or due to their geographical distribution and potentially the cost involved. Online platforms such as Clickworker or Qualtrics do provide options to recruit participants with programming skill; however, misunderstandings and fraud can be an issue. This can result in participants without programming skill taking part in studies and surveys. If these participants are not detected, they can cause detrimental noise in the survey data. In this paper, we develop screener questions that are easy and quick to answer for people with programming skill but difficult to answer correctly for those without. In order to evaluate our questionnaire for efficacy and efficiency, we recruited several batches of participants with and without programming skill and tested the questions. In our batch 42% of Clickworkers stating that they have programming skill did not meet our criteria and we would recommend filtering these from studies. We also evaluated the questions in an adversarial setting. We conclude with a set of recommended questions which researchers can use to recruit participants with programming skill from online platforms.</blockquote>

<p id="Decan2021" class="bib"><cite>Decan2021</cite>
Alexandre Decan and Tom Mens:
"<a href="https://doi.org/10.1109/tse.2019.2918315">What Do Package Dependencies Tell Us About Semantic Versioning?</a>".
<em>IEEE Transactions on Software Engineering</em>, 47(6), 2021,
<a class="doi" href="https://doi.org/10.1109/tse.2019.2918315">10.1109/tse.2019.2918315</a>.
</p>
<blockquote class="abstract">The semantic versioning (semver) policy is commonly accepted by open source package management systems to inform whether new releases of software packages introduce possibly backward incompatible changes. Maintainers depending on such packages can use this information to avoid or reduce the risk of breaking changes in their own packages by specifying version constraints on their dependencies. Depending on the amount of control a package maintainer desires to have over her package dependencies, these constraints can range from very permissive to very restrictive. This article empirically compares semver compliance of four software packaging ecosystems (Cargo, npm, Packagist and Rubygems), and studies how this compliance evolves over time. We explore to what extent ecosystem-specific characteristics or policies influence the degree of compliance. We also propose an evaluation based on the ``wisdom of the crowds'' principle to help package maintainers decide which type of version constraints they should impose on their dependencies.</blockquote>

<p id="Dias2021" class="bib"><cite>Dias2021</cite>
Edson Dias, Paulo Meirelles, Fernando Castor, Igor Steinmacher, Igor Wiese, and Gustavo Pinto:
"<a href="https://doi.org/10.1109/icse43902.2021.00093">What Makes a Great Maintainer of Open Source Projects?</a>".
<em>Proc. International Conference on Software Engineering (ICSE)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/icse43902.2021.00093">10.1109/icse43902.2021.00093</a>.
</p>
<blockquote class="abstract">Although Open Source Software (OSS) maintainers devote a significant proportion of their work to coding tasks, great maintainers must excel in many other activities beyond coding. Maintainers should care about fostering a community, helping new members to find their place, while also saying ``no'' to patches that although are well-coded and well-tested, do not contribute to the goal of the project. To perform all these activities masterfully, maintainers should exercise attributes that software engineers (working on closed source projects) do not always need to master. This paper aims to uncover, relate, and prioritize the unique attributes that great OSS maintainers might have. To achieve this goal, we conducted 33 semi-structured interviews with well-experienced maintainers that are the gatekeepers of notable projects such as the Linux Kernel, the Debian operating system, and the GitLab coding platform. After we analyzed the interviews and curated a list of attributes, we created a conceptual framework to explain how these attributes are connected. We then conducted a rating survey with 90 OSS contributors. We noted that ``technical excellence'' and ``communication'' are the most recurring attributes. When grouped, these attributes fit into four broad categories: management, social, technical, and personality. While we noted that ``sustain a long term vision of the project'' and being ``extremely careful'' seem to form the basis of our framework, we noted through our survey that the communication attribute was perceived as the most essential one.</blockquote>

<h2 id="E">E</h2>
<h2 id="F">F</h2>

<p id="Farzat2021" class="bib"><cite>Farzat2021</cite>
Fabio de A. Farzat, Marcio de O. Barros, and Guilherme H. Travassos:
"<a href="https://doi.org/10.1109/tse.2019.2928293">Evolving JavaScript Code to Reduce Load Time</a>".
<em>IEEE Transactions on Software Engineering</em>, 47(8), 2021,
<a class="doi" href="https://doi.org/10.1109/tse.2019.2928293">10.1109/tse.2019.2928293</a>.
</p>
<blockquote class="abstract">JavaScript is one of the most used programming languages for front-end development of Web applications. The increase in complexity of front-end features brings concerns about performance, especially the load and execution time of JavaScript code. In this paper, we propose an evolutionary program improvement technique to reduce the size of JavaScript programs and, therefore, the time required to load and execute them in Web applications. To guide the development of this technique, we performed an experimental study to characterize the patches applied to JavaScript programs to reduce their size while keeping the functionality required to pass all test cases in their test suites. We applied this technique to 19 JavaScript programs varying from 92 to 15,602 LOC and observed reductions from 0.2 to 73.8 percent of the original code, as well as a relationship between the quality of a program's test suite and the ability to reduce the size of its source code.</blockquote>

<p id="Feal2020" class="bib"><cite>Feal2020</cite>
'Alvaro Feal, Paolo Calciati, Narseo Vallina-Rodriguez, Carmela Troncoso, and Alessandra Gorla:
"<a href="https://doi.org/10.2478/popets-2020-0029">Angel or Devil? A Privacy Study of Mobile Parental Control Apps</a>".
<em>Proceedings on Privacy Enhancing Technologies</em>, 2020(2), 2020,
<a class="doi" href="https://doi.org/10.2478/popets-2020-0029">10.2478/popets-2020-0029</a>.
</p>
<blockquote class="abstract">Android parental control applications are used by parents to monitor and limit their children's mobile behaviour (e.g., mobile apps usage, web browsing, calling, and texting). In order to offer this service, parental control apps require privileged access to sys-tem resources and access to sensitive data. This may significantly reduce the dangers associated with kids' online activities, but it raises important privacy con-cerns. These concerns have so far been overlooked by organizations providing recommendations regarding the use of parental control applications to the public. We conduct the first in-depth study of the Android parental control app's ecosystem from a privacy and regulatory point of view. We exhaustively study 46 apps from 43 developers which have a combined 20M installs in the Google Play Store. Using a combination of static and dynamic analysis we find that: these apps are on average more permissions-hungry than the top 150 apps in the Google Play Store, and tend to request more dangerous permissions with new releases; 11% of the apps transmit personal data in the clear; 34% of the apps gather and send personal information without appropriate consent; and 72% of the apps share data with third parties (including online advertising and analytics services) without mentioning their presence in their privacy policies. In summary, parental control applications lack transparency and lack compliance with reg ulatory requirements. This holds even for those applications recommended by European and other national security centers.</blockquote>

<p id="Fritzsch2021" class="bib"><cite>Fritzsch2021</cite>
Jonas Fritzsch, Marvin Wyrich, Justus Bogner, and Stefan Wagner:
"<a href="https://doi.org/10.1109/icse-seis52602.2021.00011">RÃ©sumÃ©-Driven Development: A Definition and Empirical Characterization</a>".
<em>Proc. International Conference on Software Engineering (ICSE)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/icse-seis52602.2021.00011">10.1109/icse-seis52602.2021.00011</a>.
</p>
<blockquote class="abstract">Technologies play an important role in the hiring process for software professionals. Within this process, several studies revealed misconceptions and bad practices which lead to suboptimal recruitment experiences. In the same context, grey literature anecdotally coined the term RÃ©sumÃ©-Driven Development (RDD), a phenomenon describing the overemphasis of trending technologies in both job offerings and resumes as an interaction between employers and applicants. While RDD has been sporadically mentioned in books and online discussions, there are so far no scientific studies on the topic, despite its potential negative consequences. We therefore empirically investigated this phenomenon by surveying 591 software professionals in both hiring (130) and technical (558) roles and identified RDD facets in substantial parts of our sample: 60% of our hiring professionals agreed that trends influence their job offerings, while 82% of our software professionals believed that using trending technologies in their daily work makes them more attractive for prospective employers. Grounded in the survey results, we conceptualize a theory to frame and explain RÃ©sumÃ©-Driven Development. Finally, we discuss influencing factors and consequences and propose a definition of the term. Our contribution provides a foundation for future research and raises awareness for a potentially systemic trend that may broadly affect the software industry.</blockquote>

<h2 id="G">G</h2>
<h2 id="H">H</h2>

<p id="Hoda2021" class="bib"><cite>Hoda2021</cite>
Rashina Hoda:
"<a href="https://doi.org/10.1109/tse.2021.3106280">Socio-Technical Grounded Theory for Software Engineering</a>".
<em>IEEE Transactions on Software Engineering</em>, 2021,
<a class="doi" href="https://doi.org/10.1109/tse.2021.3106280">10.1109/tse.2021.3106280</a>.
</p>
<blockquote class="abstract">Grounded Theory (GT), a sociological research method designed to study social phenomena, is increasingly being used to investigate the human and social aspects of software engineering (SE). However, being written by and for sociologists, GT is often challenging for a majority of SE researchers to understand and apply. Additionally, SE researchers attempting ad hoc adaptations of traditional GT guidelines for modern socio-technical (ST) contexts often struggle in the absence of clear and relevant guidelines to do so, resulting in poor quality studies. To overcome these research community challenges and leverage modern research opportunities, this paper presents Socio-Technical Grounded Theory (STGT) designed to ease application and achieve quality outcomes. It defines what exactly is meant by an ST research context and presents the STGT guidelines that expand GT's philosophical foundations, provide increased clarity and flexibility in its methodological steps and procedures, define possible scope and contexts of application, encourage frequent reporting of a variety of interim, preliminary, and mature outcomes, and introduce nuanced evaluation guidelines for different outcomes. It is hoped that the SE research community and related ST disciplines such as computer science, data science, artificial intelligence, information systems, human computer/robot/AI interaction, human-centered emerging technologies (and increasingly other disciplines being transformed by rapid digitalisation and AI-based augmentation), will benefit from applying STGT to conduct quality research studies and systematically produce rich findings and mature theories with confidence.</blockquote>

<h2 id="I">I</h2>

<p id="Imam2021" class="bib"><cite>Imam2021</cite>
Ahmed Imam and Tapajit Dey:
"<a href="https://doi.org/10.1109/msr52588.2021.00085">Tracking Hackathon Code Creation and Reuse</a>".
<em>Proc. International Conference on Mining Software Repositories (MSR)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/msr52588.2021.00085">10.1109/msr52588.2021.00085</a>.
</p>
<blockquote class="abstract">Background: Hackathons have become popular events for teams to collaborate on projects and develop software prototypes. Most existing research focuses on activities during an event with limited attention to the evolution of the code brought to or created during a hackathon. Aim: We aim to understand the evolution of hackathon-related code, specifically, how much hackathon teams rely on pre-existing code or how much new code they develop during a hackathon. Moreover, we aim to understand if and where that code gets reused. Method: We collected information about 22,183 hackathon projects from Devpostâa hackathon databaseâand obtained related code (blobs), authors, and project characteristics from the World of Code. We investigated if code blobs in hackathon projects were created before, during, or after an event by identifying the original blob creation date and author, and also checked if the original author was a hackathon project member. We tracked code reuse by first identifying all commits containing blobs created during an event before determining all projects that contain those commits. Result: While only approximately 9.14% of the code blobs are created during hackathons, this amount is still significant considering time and member constraints of such events. Approximately a third of these code blobs get reused in other projects. Conclusion: Our study demonstrates to what extent pre-existing code is used and new code is created during a hackathon and how much of it is reused elsewhere afterwards. Our findings help to better understand code reuse as a phenomenon and the role of hackathons in this context and can serve as a starting point for further studies in this area.</blockquote>

<h2 id="J">J</h2>

<p id="Jin2021" class="bib"><cite>Jin2021</cite>
Xianhao Jin and Francisco Servant:
"<a href="https://doi.org/10.1109/icse43902.2021.00031">What Helped, and what did not? An Evaluation of the Strategies to Improve Continuous Integration</a>".
<em>Proc. International Conference on Software Engineering (ICSE)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/icse43902.2021.00031">10.1109/icse43902.2021.00031</a>.
</p>
<blockquote class="abstract">Continuous integration (CI) is a widely used practice in modern software engineering. Unfortunately, it is also an expensive practice - Google and Mozilla estimate their CI systems in millions of dollars. There are a number of techniques and tools designed to or having the potential to save the cost of CI or expand its benefit - reducing time to feedback. However, their benefits in some dimensions may also result in drawbacks in others. They may also be beneficial in other scenarios where they are not designed to help. In this paper, we perform the first exhaustive comparison of techniques to improve CI, evaluating 14 variants of 10 techniques using selection and prioritization strategies on build and test granularity. We evaluate their strengths and weaknesses with 10 different cost and time-tofeedback saving metrics on 100 real-world projects. We analyze the results of all techniques to understand the design decisions that helped different dimensions of benefit. We also synthesized those results to lay out a series of recommendations for the development of future research techniques to advance this area.</blockquote>

<p id="Jolak2020" class="bib"><cite>Jolak2020</cite>
Rodi Jolak and 9 others:
"<a href="https://doi.org/10.1007/s10664-020-09835-6">Software engineering whispers: The effect of textual vs. graphical software design descriptions on software design communication</a>".
<em>Empirical Software Engineering</em>, 25(6), 2020,
<a class="doi" href="https://doi.org/10.1007/s10664-020-09835-6">10.1007/s10664-020-09835-6</a>.
</p>
<blockquote class="abstract">Software engineering is a social and collaborative activity. Communicating and sharing knowledge between software developers requires much effort. Hence, the quality of communication plays an important role in influencing project success. To better understand the effect of communication on project success, more in-depth empirical studies investigating this phenomenon are needed. We investigate the effect of using a graphical versus textual design description on co-located software design communication. Therefore, we conducted a family of experiments involving a mix of 240 software engineering students from four universities. We examined how different design representations (i.e., graphical vs. textual) affect the ability to Explain, Understand, Recall, and Actively Communicate knowledge. We found that the graphical design description is better than the textual in promoting Active Discussion between developers and improving the Recall of design details. Furthermore, compared to its unaltered version, a well-organized and motivated textual design descriptionâthat is used for the same amount of timeâenhances the recall of design details and increases the amount of active discussions at the cost of reducing the perceived quality of explaining.</blockquote>

<h2 id="K">K</h2>

<p id="Kochhar2019" class="bib"><cite>Kochhar2019</cite>
Pavneet Singh Kochhar, Eirini Kalliamvakou, Nachiappan Nagappan, Thomas Zimmermann, and Christian Bird:
"<a href="https://doi.org/10.1109/tse.2019.2937025">Moving from Closed to Open Source: Observations from Six Transitioned Projects to GitHub</a>".
<em>IEEE Transactions on Software Engineering</em>, 2019,
<a class="doi" href="https://doi.org/10.1109/tse.2019.2937025">10.1109/tse.2019.2937025</a>.
</p>
<blockquote class="abstract">Open source software systems have gained a lot of attention in the past few years. With the emergence of open source platforms like GitHub, developers can contribute, store, and manage their projects with ease. Large organizations like Microsoft, Google, and Facebook are open sourcing their in-house technologies in an effort to more broadly involve the community in the development of software systems. Although closed source and open source systems have been studied extensively, there has been little research on the transition from closed source to open source systems. Through this study we aim to: a) provide guidance and insights for other teams planning to open source their projects and b) to help them avoid pitfalls during the transition process. We studied six different Microsoft systems, which were recently open-sourced i.e., CoreFX, CoreCLR, Roslyn, Entity Framework, MVC, and Orleans. This paper presents the transition from the viewpoints of both Microsoft and the open source community based on interviews with eleven Microsoft developer, five Microsoft senior managers involved in the decision to open source, and eleven open-source developers. From Microsoft's perspective we discuss the reasons for the transition, experiences of developers involved, and the transition's outcomes and challenges. Our results show that building a vibrant community, prompt answers, developing an open source culture, security regulations and business opportunities are the factors which persuade companies to open source their products. We also discuss the transition outcomes on processes such as code reviews, version control systems, continuous integration as well as developers' perception of these changes. From the open source community's perspective, we illustrate the response to the open-sourcing initiative through contributions and interactions with the internal developers and provide guidelines for other projects planning to go open source.</blockquote>

<h2 id="L">L</h2>

<p id="Lamba2020" class="bib"><cite>Lamba2020</cite>
Hemank Lamba, Asher Trockman, Daniel Armanios, Christian KÃ¤stner, Heather Miller, and Bogdan Vasilescu:
"<a href="https://doi.org/10.1145/3368089.3409705">Heard it through the Gitvine: an empirical study of tool diffusion across the npm ecosystem</a>".
<em>Proc. European Software Engineering Conference/International Symposium on the Foundations of Software Engineering (ESEC/FSE)</em>, 2020, <a class="doi" href="https://doi.org/10.1145/3368089.3409705">10.1145/3368089.3409705</a>.
</p>
<blockquote class="abstract">Automation tools like continuous integration services, code coverage reporters, style checkers, dependency managers, etc. are all known to provide significant improvements in developer productivity and software quality. Some of these tools are widespread, others are not. How do these automation ``best practices'' spread? And how might we facilitate the diffusion process for those that have seen slower adoption? In this paper, we rely on a recent innovation in transparency on code hosting platforms like GitHubâthe use of repository badgesâto track how automation tools spread in open-source ecosystems through different social and technical mechanisms over time. Using a large longitudinal data set, multivariate network science techniques, and survival analysis, we study which socio-technical factors can best explain the observed diffusion process of a number of popular automation tools. Our results show that factors such as social exposure, competition, and observability affect the adoption of tools significantly, and they provide a roadmap for software engineers and researchers seeking to propagate best practices and tools.</blockquote>

<p id="Latendresse2021" class="bib"><cite>Latendresse2021</cite>
Jasmine Latendresse, Rabe Abdalkareem, Diego Elias Costa, and Emad Shihab:
"<a href="https://doi.org/10.1109/msr52588.2021.00062">How Effective is Continuous Integration in Indicating Single-Statement Bugs?</a>".
<em>Proc. International Conference on Mining Software Repositories (MSR)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/msr52588.2021.00062">10.1109/msr52588.2021.00062</a>.
</p>
<blockquote class="abstract">Continuous Integration (CI) is the process of automatically compiling, building, and testing code changes in the hope of catching bugs as they are introduced into the code base. With bug fixing being a core and increasingly costly task in software development, the community has adopted CI to mitigate this issue and improve the quality of their software products. Bug fixing is a core task in software development and becomes increasingly costly over time. However, little is known about how effective CI is at detecting simple, single-statement bugs.In this paper, we analyze the effectiveness of CI in 14 popular open source Java-based projects to warn about 318 single-statement bugs (SStuBs). We analyze the build status at the commits that introduce SStuBs and before the SStuBs were fixed. We then investigate how often CI indicates the presence of these bugs, through test failure. Our results show that only 2% of the commits that introduced SStuBs have builds with failed tests and 7.5% of builds before the fix reported test failures. Upon close manual inspection, we found that none of the failed builds actually captured SStuBs, indicating that CI is not the right medium to capture the SStuBs we studied. Our results suggest that developers should not rely on CI to catch SStuBs or increase their CI pipeline coverage to detect single-statement bugs.</blockquote>

<p id="Lemire2021" class="bib"><cite>Lemire2021</cite>
Daniel Lemire:
"<a href="https://doi.org/10.1002/spe.2984">Number parsing at a gigabyte per second</a>".
<em>Software: Practice and Experience</em>, 51(8), 2021,
<a class="doi" href="https://doi.org/10.1002/spe.2984">10.1002/spe.2984</a>.
</p>
<blockquote class="abstract">With disks and networks providing gigabytes per second, parsing decimal numbers from strings becomes a bottleneck. We consider the problem of parsing decimal numbers to the nearest binary floating-point value. The general problem requires variable-precision arithmetic. However, we need at most 17 digits to represent 64-bit standard floating-point numbers (IEEE 754). Thus, we can represent the decimal significand with a single 64-bit word. By combining the significand and precomputed tables, we can compute the nearest floating-point number using as few as one or two 64-bit multiplications. Our implementation can be several times faster than conventional functions present in standard C libraries on modern 64-bit systems (Intel, AMD, ARM, and POWER9). Our work is available as open source software used by major systems such as Apache Arrow and Yandex ClickHouse. The Go standard library has adopted a version of our approach.</blockquote>

<p id="Lima2021" class="bib"><cite>Lima2021</cite>
Luan P. Lima, Lincoln S. Rocha, Carla I. M. Bezerra, and Matheus Paixao:
"<a href="https://doi.org/10.1007/s10664-021-09983-3">Assessing exception handling testing practices in open-source libraries</a>".
<em>Empirical Software Engineering</em>, 26(5), 2021,
<a class="doi" href="https://doi.org/10.1007/s10664-021-09983-3">10.1007/s10664-021-09983-3</a>.
</p>
<blockquote class="abstract">Modern programming languages (e.g., Java and C#) provide features to separate error-handling code from regular code, seeking to enhance software comprehensibility and maintainability. Nevertheless, the way exception handling (EH) code is structured in such languages may lead to multiple, different, and complex control flows, which may affect the software testability. Previous studies have reported that EH code is typically neglected, not well tested, and its misuse can lead to reliability degradation and catastrophic failures. However, little is known about the relationship between testing practices and EH testing effectiveness. In this exploratory study, we (i) measured the adequacy degree of EH testing concerning code coverage (instruction, branch, and method) criteria; and (ii) evaluated the effectiveness of the EH testing by measuring its capability to detect artificially injected faults (i.e., mutants) using 7 EH mutation operators. Our study was performed using test suites of 27 long-lived Java libraries from open-source ecosystems. Our results show that instructions and branches within catch blocks and throw instructions are less covered, with statistical significance, than the overall instructions and branches. Nevertheless, most of the studied libraries presented test suites capable of detecting more than 70% of the injected faults. From a total of 12, 331 mutants created in this study, the test suites were able to detect 68% of them.</blockquote>

<p id="Lunn2021" class="bib"><cite>Lunn2021</cite>
Stephanie Lunn, Monique Ross, Zahra Hazari, Mark Allen Weiss, Michael Georgiopoulos, and Kenneth Christensen:
"<a href="https://doi.org/10.1145/3430665.3456362">The Impact of Technical Interviews, and other Professional and Cultural Experiences on Students' Computing Identity</a>".
<em>Proc. Conference on Innovation and Technology in Computer Science Education (ITiCSE)</em>, 2021, <a class="doi" href="https://doi.org/10.1145/3430665.3456362">10.1145/3430665.3456362</a>.
</p>
<blockquote class="abstract">Increasingly companies assess a computing candidate's capabilities using technical interviews (TIs). Yet students struggle to code on demand, and there is already an insufficient amount of computing graduates to meet industry needs. Therefore, it is important to understand students' perceptions of TIs, and other professional experiences (e.g., computing jobs). We surveyed 740 undergraduate computing students at three universities to examine their experiences with the hiring process, as well as the impact of professional and cultural experiences (e.g., familial support) on computing identity. We considered the interactions between these experiences and social identity for groups underrepresented in computing - women, Black/African American, and Hispanic/Latinx students. Among other findings, we observed that students that did not have positive experiences with TIs had a reduced computing identity, but that facing discrimination during technical interviews had the opposite effect. Social support may play a role. Having friends in computing bolsters computing identity for Hispanic/Latinx students, as does a supportive home environment for women. Also, freelance computing jobs increase computing identity for Black/African American students. Our findings are intended to raise awareness of the best way for educators to help diverse groups of students to succeed, and to inform them of the experiences that may influence students' engagement, resilience, and computing identity development.</blockquote>

<h2 id="M">M</h2>

<p id="May2019" class="bib"><cite>May2019</cite>
Anna May, Johannes Wachs, and AnikÃ³ HannÃ¡k:
"<a href="https://doi.org/10.1007/s10664-019-09685-x">Gender differences in participation and reward on Stack Overflow</a>".
<em>Empirical Software Engineering</em>, 24(4), 2019,
<a class="doi" href="https://doi.org/10.1007/s10664-019-09685-x">10.1007/s10664-019-09685-x</a>.
</p>
<blockquote class="abstract">Programming is a valuable skill in the labor market, making the underrepresentation of women in computing an increasingly important issue. Online question and answer platforms serve a dual purpose in this field: they form a body of knowledge useful as a reference and learning tool, and they provide opportunities for individuals to demonstrate credible, verifiable expertise. Issues, such as male-oriented site design or overrepresentation of men among the site's elite may therefore compound the issue of women's underrepresentation in IT. In this paper we audit the differences in behavior and outcomes between men and women on Stack Overflow, the most popular of these Q&amp;A sites. We observe significant differences in how men and women participate in the platform and how successful they are. For example, the average woman has roughly half of the reputation points, the primary measure of success on the site, of the average man. Using an Oaxaca-Blinder decomposition, an econometric technique commonly applied to analyze differences in wages between groups, we find that most of the gap in success between men and women can be explained by differences in their activity on the site and differences in how these activities are rewarded. Specifically, 1) men give more answers than women and 2) are rewarded more for their answers on average, even when controlling for possible confounders such as tenure or buy-in to the site. Women ask more questions and gain more reward per question. We conclude with a hypothetical redesign of the site's scoring system based on these behavioral differences, cutting the reputation gap in half.</blockquote>

<h2 id="N">N</h2>
<h2 id="O">O</h2>

<p id="Olejniczak2020" class="bib"><cite>Olejniczak2020</cite>
Anthony J. Olejniczak and Molly J. Wilson:
"<a href="https://doi.org/10.1162/qss_a_00091">Who's writing open access (OA) articles? Characteristics of OA authors at Ph.D.-granting institutions in the United States</a>".
<em>Quantitative Science Studies</em>, 1(4), 2020,
<a class="doi" href="https://doi.org/10.1162/qss_a_00091">10.1162/qss_a_00091</a>.
</p>
<blockquote class="abstract">The open access (OA) publication movement aims to present research literature to the public at no cost and with no restrictions. While the democratization of access to scholarly literature is a primary focus of the movement, it remains unclear whether OA has uniformly democratized the corpus of freely available research, or whether authors who choose to publish in OA venues represent a particular subset of scholarsâthose with access to resources enabling them to afford article processing charges (APCs). We investigated the number of OA articles with article processing charges (APC OA) authored by 182,320 scholars with known demographic and institutional characteristics at American research universities across 11 broad fields of study. The results show, in general, that the likelihood for a scholar to author an APC OA article increases with male gender, employment at a prestigious institution (AAU member universities), association with a STEM discipline, greater federal research funding, and more advanced career stage (i.e., higher professorial rank). Participation in APC OA publishing appears to be skewed toward scholars with greater access to resources and job security.</blockquote>

<h2 id="P">P</h2>

<p id="Palomba2021" class="bib"><cite>Palomba2021</cite>
Fabio Palomba, Damian Andrew Tamburri, Francesca Arcelli Fontana, Rocco Oliveto, Andy Zaidman, and Alexander Serebrenik:
"<a href="https://doi.org/10.1109/tse.2018.2883603">Beyond Technical Aspects: How Do Community Smells Influence the Intensity of Code Smells?</a>".
<em>IEEE Transactions on Software Engineering</em>, 47(1), 2021,
<a class="doi" href="https://doi.org/10.1109/tse.2018.2883603">10.1109/tse.2018.2883603</a>.
</p>
<blockquote class="abstract">Code smells are poor implementation choices applied by developers during software evolution that often lead to critical flaws or failure. Much in the same way, community smells reflect the presence of organizational and socio-technical issues within a software community that may lead to additional project costs. Recent empirical studies provide evidence that community smells are oftenâif not alwaysâconnected to circumstances such as code smells. In this paper we look deeper into this connection by conducting a mixed-methods empirical study of 117 releases from 9 open-source systems. The qualitative and quantitative sides of our mixed-methods study were run in parallel and assume a mutually-confirmative connotation. On the one hand, we survey 162 developers of the 9 considered systems to investigate whether developers perceive relationship between community smells and the code smells found in those projects. On the other hand, we perform a fine-grained analysis into the 117 releases of our dataset to measure the extent to which community smells impact code smell intensity (i.e., criticality). We then propose a code smell intensity prediction model that relies on both technical and community-related aspects. The results of both sides of our mixed-methods study lead to one conclusion: community-related factors contribute to the intensity of code smells. This conclusion supports the joint use of community and code smells detection as a mechanism for the joint management of technical and social problems around software development communities.</blockquote>

<h2 id="Q">Q</h2>
<h2 id="R">R</h2>

<p id="RakAmnouykit2020" class="bib"><cite>RakAmnouykit2020</cite>
Ingkarat Rak-amnouykit, Daniel McCrevan, Ana Milanova, Martin Hirzel, and Julian Dolby:
"<a href="https://doi.org/10.1145/3426422.3426981">Python 3 types in the wild: a tale of two type systems</a>".
<em>Proc. International Symposium on Dynamic Languages (ISDL)</em>, 2020, <a class="doi" href="https://doi.org/10.1145/3426422.3426981">10.1145/3426422.3426981</a>.
</p>
<blockquote class="abstract">Python 3 is a highly dynamic language, but it has introduced a syntax for expressing types with PEP484. This paper ex- plores how developers use these type annotations, the type system semantics provided by type checking and inference tools, and the performance of these tools. We evaluate the types and tools on a corpus of public GitHub repositories. We review MyPy and PyType, two canonical static type checking and inference tools, and their distinct approaches to type analysis. We then address three research questions: (i) How often and in what ways do developers use Python 3 types? (ii) Which type errors do developers make? (iii) How do type errors from different tools compare? Surprisingly, when developers use static types, the code rarely type-checks with either of the tools. MyPy and PyType exhibit false positives, due to their static nature, but also flag many useful errors in our corpus. Lastly, MyPy and PyType embody two distinct type systems, flagging different errors in many cases. Understanding the usage of Python types can help guide tool-builders and researchers. Understanding the performance of popular tools can help increase the adoption of static types and tools by practitioners, ultimately leading to more correct and more robust Python code.</blockquote>

<p id="Rahman2020b" class="bib"><cite>Rahman2020b</cite>
Mohammad Masudur Rahman, Foutse Khomh, and Marco Castelluccio:
"<a href="https://doi.org/10.1109/icsme46990.2020.00063">Why are Some Bugs Non-Reproducible? An Empirical Investigation using Data Fusion</a>".
<em>Proc. International Conference on Software Maintenance and Evolution (ICSME)</em>, 2020, <a class="doi" href="https://doi.org/10.1109/icsme46990.2020.00063">10.1109/icsme46990.2020.00063</a>.
</p>
<blockquote class="abstract">Software developers attempt to reproduce software bugs to understand their erroneous behaviours and to fix them. Unfortunately, they often fail to reproduce (or fix) them, which leads to faulty, unreliable software systems. However, to date, only a little research has been done to better understand what makes the software bugs non-reproducible. In this paper, we conduct a multimodal study to better understand the non-reproducibility of software bugs. First, we perform an empirical study using 576 non-reproducible bug reports from two popular software systems (Firefox, Eclipse) and identify 11 key factors that might lead a reported bug to non-reproducibility. Second, we conduct a user study involving 13 professional developers where we investigate how the developers cope with non-reproducible bugs. We found that they either close these bugs or solicit for further information, which involves long deliberations and counter-productive manual searches. Third, we offer several actionable insights on how to avoid non-reproducibility (e.g., false-positive bug report detector) and improve reproducibility of the reported bugs (e.g., sandbox for bug reproduction) by combining our analyses from multiple studies (e.g., empirical study, developer study).</blockquote>

<p id="Rahman2021" class="bib"><cite>Rahman2021</cite>
Akond Rahman, Md Rayhanur Rahman, Chris Parnin, and Laurie Williams:
"<a href="https://doi.org/10.1145/3408897">Security Smells in Ansible and Chef Scripts</a>".
<em>ACM Transactions on Software Engineering and Methodology</em>, 30(1), 2021,
<a class="doi" href="https://doi.org/10.1145/3408897">10.1145/3408897</a>.
</p>
<blockquote class="abstract">Context: Security smells are recurring coding patterns that are indicative of security weakness and require further inspection. As infrastructure as code (IaC) scripts, such as Ansible and Chef scripts, are used to provision cloud-based servers and systems at scale, security smells in IaC scripts could be used to enable malicious users to exploit vulnerabilities in the provisioned systems. Goal: The goal of this article is to help practitioners avoid insecure coding practices while developing infrastructure as code scripts through an empirical study of security smells in Ansible and Chef scripts. Methodology: We conduct a replication study where we apply qualitative analysis with 1,956 IaC scripts to identify security smells for IaC scripts written in two languages: Ansible and Chef. We construct a static analysis tool called Security Linter for Ansible and Chef scripts (SLAC) to automatically identify security smells in 50,323 scripts collected from 813 open source software repositories. We also submit bug reports for 1,000 randomly selected smell occurrences. Results: We identify two security smells not reported in prior work: missing default in case statement and no integrity check. By applying SLAC we identify 46,600 occurrences of security smells that include 7,849 hard-coded passwords. We observe agreement for 65 of the responded 94 bug reports, which suggests the relevance of security smells for Ansible and Chef scripts amongst practitioners. Conclusion: We observe security smells to be prevalent in Ansible and Chef scripts, similarly to that of the Puppet scripts. We recommend practitioners to rigorously inspect the presence of the identified security smells in Ansible and Chef scripts using (i) code review, and (ii) static analysis tools.</blockquote>

<p id="Rodeghero2021" class="bib"><cite>Rodeghero2021</cite>
Paige Rodeghero, Thomas Zimmermann, Brian Houck, and Denae Ford:
"<a href="https://doi.org/10.1109/icse-seip52600.2021.00013">Please Turn Your Cameras on: Remote Onboarding of Software Developers During a Pandemic</a>".
<em>Proc. International Conference on Software Engineering (ICSE)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/icse-seip52600.2021.00013">10.1109/icse-seip52600.2021.00013</a>.
</p>
<blockquote class="abstract">The COVID-19 pandemic has impacted the way that software development teams onboard new hires. Previously, most software developers worked in physical offices and new hires onboarded to their teams in the physical office, following a standard onboarding process. However, when companies transitioned employees to work from home due to the pandemic, there was little to no time to develop new onboarding procedures. In this paper, we present a survey of 267 new hires at Microsoft that onboarded to software development teams during the pandemic. We explored their remote onboarding process, including the challenges that the new hires encountered and their social connectedness with their teams. We found that most developers onboarded remotely and never had an opportunity to meet their teammates in person. This leads to one of the biggest challenges faced by these new hires, building a strong social connection with their team. We use these results to provide recommendations for onboarding remote hires.</blockquote>

<h2 id="S">S</h2>

<p id="Shao2020" class="bib"><cite>Shao2020</cite>
Shudi Shao, Zhengyi Qiu, Xiao Yu, Wei Yang, Guoliang Jin, Tao Xie, and Xintao Wu:
"<a href="https://doi.org/10.1109/icsme46990.2020.00016">Database-Access Performance Antipatterns in Database-Backed Web Applications</a>".
<em>Proc. International Conference on Software Maintenance and Evolution (ICSME)</em>, 2020, <a class="doi" href="https://doi.org/10.1109/icsme46990.2020.00016">10.1109/icsme46990.2020.00016</a>.
</p>
<blockquote class="abstract">Database-backed web applications are prone to performance bugs related to database accesses. While much work has been conducted on database-access antipatterns with some recent work focusing on performance impact, there still lacks a comprehensive view of database-access performance antipatterns in database-backed web applications. To date, no existing work systematically reports known antipatterns in the literature, and no existing work has studied database-access performance bugs in major types of web applications that access databases differently.To address this issue, we first summarize all known database-access performance antipatterns found through our literature survey, and we report all of them in this paper. We further collect database-access performance bugs from web applications that access databases through language-provided SQL interfaces, which have been largely ignored by recent work, to check how extensively the known antipatterns can cover these bugs. For bugs not covered by the known antipatterns, we extract new database-access performance antipatterns based on real-world performance bugs from such web applications. Our study in total reports 24 known and 10 new database-access performance antipatterns. Our results can guide future work to develop effective tool support for different types of web applications.</blockquote>

<p id="Sharma2021" class="bib"><cite>Sharma2021</cite>
Pankajeshwara Nand Sharma, Bastin Tony Roy Savarimuthu, and Nigel Stanger:
"<a href="https://doi.org/10.1109/icse43902.2021.00095">Extracting Rationale for Open Source Software Development DecisionsâA Study of Python Email Archives</a>".
<em>Proc. International Conference on Software Engineering (ICSE)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/icse43902.2021.00095">10.1109/icse43902.2021.00095</a>.
</p>
<blockquote class="abstract">A sound Decision-Making (DM) process is key to the successful governance of software projects. In many Open Source Software Development (OSSD) communities, DM processes lie buried amongst vast amounts of publicly available data. Hidden within this data lie the rationale for decisions that led to the evolution and maintenance of software products. While there have been some efforts to extract DM processes from publicly available data, the rationale behind 'how' the decisions are made have seldom been explored. Extracting the rationale for these decisions can facilitate transparency (by making them known), and also promote accountability on the part of decision-makers. This work bridges this gap by means of a large-scale study that unearths the rationale behind decisions from Python development email archives comprising about 1.5 million emails. This paper makes two main contributions. First, it makes a knowledge contribution by unearthing and presenting the rationale behind decisions made. Second, it makes a methodological contribution by presenting a heuristics-based rationale extraction system called Rationale Miner that employs multiple heuristics, and follows a data-driven, bottom-up approach to infer the rationale behind specific decisions (e.g., whether a new module is implemented based on core developer consensus or benevolent dictator's pronouncement). Our approach can be applied to extract rationale in other OSSD communities that have similar governance structures.</blockquote>

<h2 id="T">T</h2>

<p id="Tamburri2020" class="bib"><cite>Tamburri2020</cite>
Damian Andrew Tamburri, Kelly Blincoe, Fabio Palomba, and Rick Kazman:
"<a href="https://doi.org/10.1002/spe.2874">'The Canary in the Coal Mineâ¦' A cautionary tale from the decline of SourceForge</a>".
<em>Software: Practice and Experience</em>, 50(10), 2020,
<a class="doi" href="https://doi.org/10.1002/spe.2874">10.1002/spe.2874</a>.
</p>
<blockquote class="abstract">Forges are online collaborative platforms to support the development of distributed open source software. While once mighty keepers of open source vitality, software forges are rapidly becoming less and less relevant. For example, of the top 10 forges in 2011, only one survives todayâSourceForgeâthe biggest of them all, but its numbers are dropping and its community is tenuous at best. Through mixed-methods research, this article chronicles and analyze the software practice and experiences of the project's historyâin particular its architectural and community/organizational decisions. We discovered a number of suboptimal social and architectural decisions and circumstances that, may have led to SourceForge's demise. In addition, we found evidence suggesting that the impact of such decisions could have been monitored, reduced, and possibly avoided altogether. The use of sociotechnical insights needs to become a basic set of design and software/organization monitoring principles that tell a cautionary tale on what to measure and what not to do in the context of large-scale software forge and community design and management.</blockquote>

<p id="Tomasdottir2020" class="bib"><cite>Tomasdottir2020</cite>
KristÃ­n FjÃ³la TÃ³masdÃ³ttir, MaurÃ­cio Aniche, and Arie van Deursen:
"<a href="https://doi.org/10.1109/tse.2018.2871058">The Adoption of JavaScript Linters in Practice: A Case Study on ESLint</a>".
<em>IEEE Transactions on Software Engineering</em>, 46(8), 2020,
<a class="doi" href="https://doi.org/10.1109/tse.2018.2871058">10.1109/tse.2018.2871058</a>.
</p>
<blockquote class="abstract">A linter is a static analysis tool that warns software developers about possible code errors or violations to coding standards. By using such a tool, errors can be surfaced early in the development process when they are cheaper to fix. For a linter to be successful, it is important to understand the needs and challenges of developers when using a linter. In this paper, we examine developers' perceptions on JavaScript linters. We study why and how developers use linters along with the challenges they face while using such tools. For this purpose we perform a case study on ESLint, the most popular JavaScript linter. We collect data with three different methods where we interviewed 15 developers from well-known open source projects, analyzed over 9,500 ESLint configuration files, and surveyed 337 developers from the JavaScript community. Our results provide practitioners with reasons for using linters in their JavaScript projects as well as several configuration strategies and their advantages. We also provide a list of linter rules that are often enabled and disabled, which can be interpreted as the most important rules to reason about when configuring linters. Finally, we propose several feature suggestions for tool makers and future work for researchers.</blockquote>

<p id="Turcotte2020" class="bib"><cite>Turcotte2020</cite>
Alexi Turcotte, Aviral Goel, Filip KÅikava, and Jan Vitek:
"<a href="https://doi.org/10.1145/3428249">Designing types for R, empirically</a>".
<em>Proceedings of the ACM on Programming Languages</em>, 4(OOPSLA), 2020,
<a class="doi" href="https://doi.org/10.1145/3428249">10.1145/3428249</a>.
</p>
<blockquote class="abstract">The R programming language is widely used in a variety of domains. It was designed to favor an interactive style of programming with minimal syntactic and conceptual overhead. This design is well suited to data analysis, but a bad fit for tools such as compilers or program analyzers. In particular, R has no type annotations, and all operations are dynamically checked at run-time. The starting point for our work are the two questions: what expressive power is needed to accurately type R code? and which type system is the R community willing to adopt? Both questions are difficult to answer without actually experimenting with a type system. The goal of this paper is to provide data that can feed into that design process. To this end, we perform a large corpus analysis to gain insights in the degree of polymorphism exhibited by idiomatic R code and explore potential benefits that the R community could accrue from a simple type system. As a starting point, we infer type signatures for 25,215 functions from 412 packages among the most widely used open source R libraries. We then conduct an evaluation on 8,694 clients of these packages, as well as on end-user code from the Kaggle data science competition website.</blockquote>

<h2 id="U">U</h2>
<h2 id="V">V</h2>
<h2 id="W">W</h2>
<h2 id="X">X</h2>
<h2 id="Y">Y</h2>

<p id="Young2021" class="bib"><cite>Young2021</cite>
Jean-Gabriel Young, Amanda Casari, Katie McLaughlin, Milo Z. Trujillo, Laurent Hebert-Dufresne, and James P. Bagrow:
"<a href="https://doi.org/10.1109/msr52588.2021.00036">Which contributions count? Analysis of attribution in open source</a>".
<em>Proc. International Conference on Mining Software Repositories (MSR)</em>, 2021, <a class="doi" href="https://doi.org/10.1109/msr52588.2021.00036">10.1109/msr52588.2021.00036</a>.
</p>
<blockquote class="abstract">Open source software projects usually acknowledge contributions with text files, websites, and other idiosyncratic methods. These data sources are hard to mine, which is why contributorship is most frequently measured through changes to repositories, such as commits, pushes, or patches. Recently, some open source projects have taken to recording contributor actions with standardized systems; this opens up a unique opportunity to understand how community-generated notions of contributorship map onto codebases as the measure of contribution. Here, we characterize contributor acknowledgment models in open source by analyzing thousands of projects that use a model called All Contributors to acknowledge diverse contributions like outreach, finance, infrastructure, and community management. We analyze the life cycle of projects through this model's lens and contrast its representation of contributorship with the picture given by other methods of acknowledgment, including GitHub's top committers indicator and contributions derived from actions taken on the platform. We find that community-generated systems of contribution acknowledgment make work like idea generation or bug finding more visible, which generates a more extensive picture of collaboration. Further, we find that models requiring explicit attribution lead to more clearly defined boundaries around what is and is not a contribution.</blockquote>
